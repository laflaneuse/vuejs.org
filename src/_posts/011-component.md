---
title: 0.11 Μυστικά για Component
date: 2014-12-08 15:02:14
tags:
---

<p class="tip">Σημείωση: αυτό το άρθρο περιέχει πληροφορίες για την παρωχημένη έκδοση 0.11. Παρακαλώ διαβάστε [τις σημειώσεις έκδοσης 0.12](https://github.com/yyx990803/vue/releases) για αλλαγές που έχουν γίνει στο API.</p>

Η έκδοση 0.11 έχει εισάγει [πολλές αλλαγές](https://github.com/yyx990803/vue/blob/master/changes.md), αλλά η σημαντικότερη είναι το πως λειτουργεί το πεδίο δράσης _(scope)_ των components λειτουργεί. Προηγουμένως, στην έκδοση 0.10.x, τα components κληρονομούσαν το πεδίο δράσης _(scope)_ εξ ορισμού. Αυτό σημαίνει, πως στο πρότυπο _(template)_ ενός υπό-component μπορείτε να κάνετε αναφορά στις ιδιότητες του γονικού πεδίου δράσης _(scope)_. Αυτό συχνά έχει ως αποτέλεσμα τα σφιχτά δεμένα components, όπου ένα υπό-component υποθέτει πως το γονικό component θα έχεις όλες τις απαιτούμενες ιδιότητες. Επίσης είναι πιθανό να γίνει κατά λάθος αναφορά σε ιδιότητες του γονικού πεδίου δράσης _(scope)_ σε ένα υπό-component.

<!-- more -->

### Απομονωμένο πεδίο δράσης και μεταβίβαση δεδομένων

Με την έκδοση 0.11, όλα τα υπό-components έχουν απομονωμένο πεδίο δράσης _(scope)_ εξ-ορισμού, και ο προτεινόμενος τρόπος για να ελέγξετε την πρόσβαση στα δεδομένα είναι μέσω [ρητής μεταβίβασης δεδομένων](/guide/components.html#Explicit_Data_Passing) χρησιμοποιώντας [`v-with`](/api/directives.html#v-with) ή [`paramAttributes`](/api/options.html#paramAttributes).

Το `paramAttributes` μας επιτρέπει να γράψουμε πρότυπα Web Component:

``` js
Vue.component('my-component', {
  paramAttributes: ['params'],
  compiled: function () {
    console.log(this.params) // μεταβιβάστηκε από το γονικό component
  }
})
```

``` html
<my-component params="{{params}}"></my-component>
```

### Που ανήκει;

Προηγουμένως, στην έκδοση 0.10, όλες οι ντιρεκτίβες σε ένα στοιχείο πλαισίου με components μεταφέρονται στο πεδίο δράσης _(scope)_ των υπό-components. Επειδή κληρονομούσαν το γονικό πεδίο δράσης _(scope)_, αυτό λειτουργούσε τις περισσότερες περιπτώσεις. Με την έκδοση 0.11.1, θέλουμε να παρέχουμε ποιο καθαρό διαχωρισμό μεταξύ των πεδίων δράσης _(scope)_ των components. Ο κανόνας είναι: Αν κάτι εμφανίζετε στο γονικό πρότυπο _(template)_, θα παραμένει στο γονικό πεδίο δράσης _(scope)_. Αν κάτι εμφανίζετε στο πρότυπο _(template)_ ενός υπό-component, θα παραμένει στο πεδίο δράσης _(scope)_ του υπό-component. Για παράδειγμα:

``` html
<!-- γονικό πρότυπο -->
<div v-component="child" v-on="click:onParentClick">
  <p>{{parentMessage}}</p>
</div>
```

``` html
<!-- πρότυπο υπό-component, με replace: true -->
<div v-on="click:onChildClick">
  <h1>{{childMessage}}</h1>
  <content></content>
</div>
```

Οτιδήποτε είναι στο πρότυπο _(template)_ του γονικού component θα παραμείνει στο πεδίο δράσης _(scope)_ του γονικού component, συμπεριλαμβανομένου και του περιεχομένου που θα κληροδοτηθεί στο υπό-component

Η μόνη εξαίρεση στον κανόνα είναι το `v-with` (και `paramAttributes` που μεταφέρονται κάτω στο `v-with`), που λειτουργεί και στις δυο πλευρές, οπότε δεν πρέπει να ανησυχείτε και πολύ για αυτό.

### Καλύτερη επικοινωνία με συμβάντα

Στην προηγούμενη έκδοση ο εξ ορισμού τρόπος επικοινωνίας ενός υπό-component με το γονικό του component ήταν μέσω αποστολής συμβάντων. Ωστόσο, με αυτή την προσέγγιση, οι ακροατές συμβάντων στο γονικό component δεν είναι εγγυημένο πως θα ακούν μόνο το επιθυμητό υπό-component. Είναι επίσης δυνατόν να ενεργοποιηθούν ακροατές ποιο ψηλά στην ιεραρχία των components αν δεν ακυρώσουμε το συμβάν.

Η ποιο κοινή χρήση είναι ένας γονέας να αντιδρά στα συμβάντα συγκεκριμένων, άμεσων υπό-components. Έτσι, στην έκδοση 0.11.4, [η νέα ντιρεκτίβα `v-events`](/api/directives.html#v-events) έχει εισαχθεί για να ενεργοποιήσει αυτή ακριβώς την συμπεριφορά.

Η έκδοση 0.11.4 έχει ήδη δημοσιευθεί, οπότε δοκιμάστε την!
