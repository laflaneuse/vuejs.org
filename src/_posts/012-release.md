---
title: Κυκλοφόρησε η έκδοση 0.12 του Vue.js 0.12!
date: 2015-06-11 17:37:30
---

Είμαι ενθουσιασμένος που ανακοινώνω πως η έκδοση [Vue.js 0.12: Dragon Ball](https://github.com/yyx990803/vue/releases/tag/0.12.0) είναι τελικά εδώ! Ευχαριστούμε όλους όσους δοκίμασαν τις εκδόσεις beta/rc και μας παρείχαν αναφορές ανατροφοδότησης / σφαλμάτων σε όλη την διαδρομή μέχρι εδώ.

Αυτή η έκδοση καλύπτει πάρα πολλά, και για αυτό θα μιλήσουμε μόνο για μερικά  σημαντικά σημεία παρακάτω. Ωστόσο, είναι σημαντικό να διαβάσετε προσεκτικά την [Πλήρη Αναφορά Έκδοσης](https://github.com/yyx990803/vue/releases/tag/0.12.0) και τα ενημερωμένα έγγραφα αν αναβαθμίζεστε από την έκδοση 0.11. Μπορείτε να αναφαίρετε σφάλματα στο GitHub, να στείλετε ερωτήσεις στο [vuejs/Discussion](https://github.com/vuejs/Discussion/issues), ή να μπείτε στην παρέα μας στο [Gitter chat channel](https://gitter.im/yyx990803/vue).

<!-- more -->

### Ποιο Σταθερό Συντακτικό για τα Components

Προηγουμένως, στην έκδοση 0.11 είχατε δυο τρόπους να χρησιμοποιήσετε τα Components του Vue.js: είτε χρησιμοποιώντας την ντιρεκτίβα `v-component`, είτε χρησιμοποιώντας δικά σας στοιχεία. Υπάρχουν επίσης δυο τρόποι για να μεταφέρετε δεδομένα σε υπό-στοιχεία _(child components)_: είτε χρησιμοποιώντας την ντιρεκτίβα `v-with`, είτε χρησιμοποιώντας την ιδιότητα `paramAttributes`. Αν και τόσο δικά σας στοιχεία όσο και οι ιδιότητες param μεταφράζονται τελικά σε ντιρεκτίβες, Αν και τόσο δικά σας στοιχεία όσο και οι ιδιότητες param μεταφράζονται τελικά σε ντιρεκτίβες, μπερδεύουν και είναι περιττό να έχεις δυο σύνολα συντακτικού για την ίδια λειτουργικότητα.

Επιπλέον, θα πρέπει να σημειωθεί πως το σύστημα των στοιχείων _(components)_ αποτελούν βασική ιδέα στο Vue.js, και είναι ακόμα ποιο σημαντικά και από τις ντιρεκτίβες. Τα στοιχεία _(components)_ ορίζουν το τρόπο που ενθυλακώνουμε την λογική προβολής υψηλού επιπέδου και την σύνθεση της εφαρμογής μας. Την ίδια στιγμή, είναι πολύ σημαντικό να υπάρχει ένα καθαρός και δηλωτικός τρόπος για την μεταβίβαση δεδομένων σε υπό-στοιχεία _(child components)_. Τα στοιχεία _(components)_ και οι ιδιότητες param αξίζουν πραγματικά το δικό τους συντακτικό για να διαφοροποιηθούν από τις άλλες ντιρεκτίβες.

Ως αποτέλεσμα, οι `v-component` και `v-with` έχουν απαγορευτεί στην έκδοση 0.12. Η `paramAttributes` έχει επίσης μετονομαστεί σε `props`, που είναι ποιο σύντομη και ποιο καθαρή. Από εδώ και στο εξής, τα περισσότερα στοιχεία _(components)_ του Vue.js θα μοιάζουν με το ακόλουθο:

``` html
<my-component prop="{{parentData}}"></my-component>
```

Υπάρχουν επίσης επιπλέον βελτιώσεις σχετικά με τα props, όπως ρητές μιας φοράς ή μιας κατεύθυνσης props, εκφράσεις ως props, μέθοδοι ανάκλησης ως props και άλλα. Μπορείτε να βρείτε περισσότερες πληροφορίες στης σημειώσεις έκδοσης της 0.12 που αναφέραμε παραπάνω και στο ενημερωμένο τμήμα του οδηγού για το [Σύστημα Στοιχείων](/guide/components.html).

### Βελτίωση Παραμέτρων στα Φίλτρα

Στην έκδοση 0.11,  τα φίλτρα πάντα λαμβάνουν τις παραμέτρους τους ως απλό κείμενο. Μια παράμετρος μπορεί να εσωκλείεται σε εισαγωγικά για να περιέχει λευκούς χαρακτήρες _(καινά, νέες γραμμές, κα.)_, αλλά τα εισαγωγικά δεν αφαιρούνται αυτόματα όταν η παράμετρος περάσει στην συνάρτηση του φίλτρου. Επίσης, κάποιοι χρήστες μπερδεύονται όταν πρέπει να ανακτήσουν δυναμικές τιμές στο vm αντί για απλό κείμενο.

Στην έκδοση 0.12, το συντακτικό των παραμέτρων στα φίλτρα ακολουθεί απλούς κανόνες: Αν μια παράμετρος εσωκλείεται σε εισαγωγικά, θα μεταφερθεί στην συνάρτηση του φίλτρου ως απλό κείμενο, διαφορετικά, θα αξιολογηθεί με βάση τρέχων vm ως δυναμική τιμή.

Αυτό σημαίνει πως η χρήση κάποιον υφιστάμενων φίλτρον θα πρέπει να αλλάξουν:

``` html
<a v-on="keyup: onKeyUp | key 'enter'"></a>
{{ items.length | pluralize 'item' }}
```

Αλλά θα κάνει προσαρμοσμένα φίλτρα που εξαρτώνται από δυναμικές τιμές να είναι ποιο εύκολα στην συγγραφή τους:

``` html
{{ msg | concat otherMsg }}
```

Εδώ, η πρώτη παράμετρος του φίλτρου `concat` θα είναι η τιμή του `this.otherMsg`.

### Ασύγχρονα Στοιχεία

Είναι κοινή πρακτική να έχετε όλη την JavaScript σε ένα αρχείο όταν δημιουργείτε μεγάλες εφαρμογές μιας σελίδας. Αλλά, όταν το αρχείο γίνετε πάρα πολύ μεγάλο, ίσως χρειάζεται να αναβάλουμε την φόρτωση μερικών τμημάτων της εφαρμογής για ταχύτερο πρώτο φόρτωμα της. Ωστόσο, αυτό δημιουργεί κάποιους περιορισμούς στο πως η εφαρμογή θα πρέπει να σχεδιαστεί. Μπορεί να είναι πολύ δύσκολο να καταλάβει κάποιος πως να διασπάσει τα πακέτα της JavaScript.

Λοιπόν, με το Vue.js μπορούμε ήδη να χτίσουμε την εφαρμογή μας ως αποσυνδεδεμένα στοιχεία. Δεν θα ήταν υπέροχο αν μπορούμε να φορτώσουμε βαρετά _(lazily)_ ένα δυναμικό στοιχείο όταν το χρειαζόμαστε; Στην πραγματικότητα, στην έκδοση 0.12 αυτό είναι πολύ εύκολο με το νέο χαρακτηριστικό ασύγχρονων στοιχείων.

Στην έκδοση 0.12 μπορείτε να ορίσετε ένα στοιχεί ως factory συνάρτηση που ασύγχρονα επιλύει μια δήλωση στοιχείου (Μπορεί να είναι ένα απλό αντικείμενο ιδιοτήτων). Το Vue.js θα εκτελέσει μόνο την factory συνάρτηση μόνο όταν το στοιχείο είναι απαραίτητο να απεικονιστεί, και θα αποθηκεύσει
προσωρινά _(cache)_ το αποτέλεσμα  για μελλοντική απεικονίσεις.

``` js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    resolve({
      template: '<div>Είμαι ασύγχρονο!</div>'
    })
  }, 1000)
})
```

Είναι στην δική σας ευκαίρια το πως θα φορτώσετε το στοιχείο από τον server, πχ.  `$.getScript()` ή require.js, αλλά συνίσταται η χρήση σε συνδυασμό με το [χαρακτηριστικό διαχωρισμού κώδικα](http://webpack.github.io/docs/code-splitting.html) του Webpack:

``` js
Vue.component('async-webpack-example', function (resolve, reject) {
  // Στο συντακτικό τύπου AMD του Webpack υποδεικνύουμε ένα σημείο διαχωρισμού κώδικα.
  require(['./my-async-component'], resolve)
})
```

Αυτό είναι όλο. Μπορείτε να χρησιμοποιήσετε το στοιχείο ακριβώς όπως και πριν, χωρίς καν να σκεφτείτε πως είναι ασύγχρονο το φόρτωμα του. Το Webpack αυτόματα θα διασπάσει τον τελικό κώδικα JavaScript σε διαφορετικά πακέτα με τις σωστές εξαρτήσεις, και αυτόματα θα φορτώσει τα πακέτα μέσω AJAX όταν αυτά χρειάζονται. Μπορείτε να δείτε ένα πλήρως λειτουργικό παράδειγμα [εδώ](https://github.com/vuejs/vue-webpack-example).

### Βελτιωμένο Σύστημα Μεταβάσεων

Το σύστημα μεταβάσεων του Vue.js είναι πραγματικά πολύ εύκολο στην χρήση του, αλλά στο παρελθόν ήταν περιοριστικό με την ταυτόχρονη χρήση CSS και JavaScript μαζί. Στην έκδοση 0.12, αυτό πλέον δεν αποτελεί πρόβλημα! Το βελτιωμένο σύστημα μεταβάσεων τώρα σας επιτρέπει να εισάγετε σημεία ελέγχου _(hooks)_ στις μεταβάσεις που βασίζονται σε CSS για επιπλέον έλεγχο. Το πλήθος των διαθέσιμων σημείων ελέγχου έχει επίσης επεκταθεί για να δώσει ακόμα ποιο λεπτομερή έλεγχο σε κάθε τμήμα της μετάβασης.

Η `v-repeat` πλέον έρχεται με προ-εγκατεστημένη υποστήριξη για κλιμακωτές μεταβάσεις. Είναι τόσο απλό όσο το να βάλετε το `stagger="100"` στα επαναλαμβανόμενα στοιχεία σας. Είναι επίσης εφικτό να ορίσετε ξεχωριστή κλιμάκωση για την είσοδο και την έξοδο, ή ακόμα να υπολογίσετε δυναμικά την καθυστέρηση κλιμάκωσης σε ένα σημείο ελέγχου JavaScript.

Για πλήρη αναφορά στο νέο σύστημα μεταβάσεων, ελέγξτε τον [ενημερωμένο οδηγό](/guide/transitions.html).

### Βελτιωμένη Απόδοση

Στο Vue.js' η ακριβής παρακολούθηση των εξαρτήσεων το κάνει ένα από τα ποιο αποδοτικά επίπεδα προβολής στα μικρής κλίμακας ενημερώσεις, αλλά πάντα υπάρχει χώρος για βελτίωση. Στην έκδοση 0.12, η εσωτερική δημιουργία στιγμιοτύπων και η επανεγγραφή του μεταγλωττιστή έχει βελτιώσει την πρώτη απεικόνιση σε μεγάλες λίστες μέχρι και 40%. Με σωστή χρήση της `track-by`, [η επαναλαμβανόμενη απεικόνιση με μεγάλα, ολοκαίνουρια σύνολα δεδομένων](http://vuejs.github.io/js-repaint-perfs/vue/) είναι επίσης συγκρίσιμη ή και ακόμα ταχύτερη από άλλες πλατφόρμες βασισμένες σε εικονικό DOM.

### Ένα τελευταίο πράγμα...

Με την έκδοση 0.12 έξω από την πόρτα, οι μεγαλύτερη προσπάθεια τώρα θα καταναλωθεί στην επίσημη βιβλιοθήκη vue-router, μια βιβλιοθήκη αφοσιωμένη στο Vue.js με ενθυλακωμένα ταιριάσματα προβολών, υποστήριξη πλήρους μετάβασης και ασύγχρονα σημεία ελέγχου δεδομένων. Έχω εκφράσει πως ο πυρήνας του Vue.js σκοπεύει να παραμείνει ως no-frills, drop-in view layer library, και πως δεν θα αλλάξει. Η βιβλιοθήκη vue-router θα κυκλοφορήσει ξεχωριστά και θα είναι εντελώς προαιρετική, ωστόσο θα πρέπει να αναμένετε πως θα λειτουργήσει άψογα με τον πύρινα του Vue.js όταν θα το χρειάζεστε.
